//=======================================================================
// Copyright 2008, Dalhousie University
// Author: Donovan Parks
//
// The contents of this file are licensed under the 
// Attribution-ShareAlike Creative Commons License:
// http://creativecommons.org/licenses/by-sa/3.0/
//=======================================================================

#ifndef _OPT_LEAF_ORDER_
#define _OPT_LEAF_ORDER_

#include "../core/Precompiled.hpp"

#include "../core/NodePhylo.hpp"

#include "../utils/Tree.hpp"

namespace pygmy 
{

class OptimizeLeafOrder
{
public:
	/**
	 * @brief Find optimal leaf ordering of a tree using branch and bound in order to reduce required computation.
	 *				Note: This algorithm is designed to work with multifurcating trees.
	 * @param tree Tree to optimize leaf node ordering of.
	 * @param metadataInfo Summary information about metadata associated with tree.
	 * @param field Metadata field to perform optimization on.
	 * @param numCrossings Number of crossings that occurs after optimizing leaf node order.
	 * @param bOptimize Flag indicating if optimal ordering should be found (true) or if a heuristic ordering should be used (false).
	 */
	static void OptimizeLeafNodeOrdering(utils::Tree<NodePhylo>::Ptr tree, MetadataInfoPtr metadataInfo, const std::wstring& field,
																					uint& numCrossings, bool bOptimize);

	/**
	 * @brief Perform Monte Carlo significance test between tree topology and position of points on layout primative.
	 * @param tree Tree significance test will be performed on.
	 * @param node Subtree to perform significance test on.
	 * @param iterations Number of iterations to perform when creating probability density function.
	 * @param pdf Probability density function generated by significance test.
	 * @return P-value from significance test.
	 */
	static double SignificanceTest(utils::Tree<NodePhylo>::Ptr tree, NodePhylo* node, uint iterations, std::map<uint, uint>& pdf);

protected:
	/**
	 * @brief Find optimal leaf ordering of a tree using branch and bound in order to reduce required computation.
	 *				Note: This algorithm is designed to work with multifurcating trees.
	 * @param node Tree (subtree) to find optimal leaf ordering for.
	 * @param numCrossings Number of crossings that occurs after optimizing leaf node order.
	 * @param bOptimize Flag indicating if optimal ordering should be found (true) or if a heuristic ordering should be used (false).
	 */
	static void BranchAndBoundTreeOpt(NodePhylo* node, uint& numCrossings, bool bOptimize);

	/**
	 * @brief Count number of crossings between the subtrees below a given node (crossings within a subtree are not counted).
	 * @param node Crossings between subtrees below this node will be counted.
	 * @param leafOrder Desired order of leaf nodes (from left to right).
	 * @param maxCrossings Function will return immediately after counting more than this many crossings.
	 * @return Number of crossings.
	 */
	static uint CountCrossingsByInversionNumber(NodePhylo* node, uint maxCrossings = INT_MAX);

	/**
	 * @brief Create a count matrix which indicates the number of crossings between any two subtrees below the given node.
	 *				Note: crossings within a subtree are not counted.
	 * @param node Crossings between subtrees below this node will be tabulated into a counting matrix.
	 * @param countMatrix Count matrix to be populated.
	 */
	static void CreateCountMatrix(NodePhylo* node, std::vector< std::vector<uint> >& countMatrix);

	/**
	 * @brief Calculate the canonical lower bound on the number of crossings.
	 * @param countMatrix Count matrix indicating number of crossings between any pair of subtrees (see CreateCountMatrix).
	 */
	static uint CanonicalLowerBound(const std::vector< std::vector<uint> >& countMatrix);

	/**
	 * @brief Calculate the ordering of subtrees below the given nodes as determined by the barycenter heuristic.
	 * @param baryCenterOrdering The barycenter ordering.
	 */
	static void BaryCenterOrdering(NodePhylo* node, std::vector<uint>& baryCenterOrdering);

	/**
	 * @brief Calculate the ordering of subtrees below the given nodes as determined by the median heuristic.
	 * @param medianOrdering The median ordering.
	 */
	static void MedianOrdering(NodePhylo* node, std::vector<uint>& medianOrdering);

	/** Randomly permute a vector. */
	static void RandomPermutation(std::vector<uint>& leafOrder);

protected:

};

}

#endif
